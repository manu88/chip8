//
//  Disassembler.cpp
//  asm
//
//  Created by Manuel Deneu on 25/03/2025.
//

#include "Disassembler.hpp"
#include "HexHelpers.hpp"
#include <assert.h>

std::string Disassembler::generate() {
    if (!params.noAutogeneratedComments) {
        _text = "; autogenerated from chip8 disassembler\n";
    }
    for (int i = 0; i < _bytes.size(); i += 2) {
        uint8_t b0 = _bytes[i];
        uint8_t b1 = _bytes[i + 1];
        uint16_t instr = (b0 << 8) + b1;
        if (!exec(instr)) {
            printf("Error at instruction 0X%04X\n", instr);
            return "";
        }
        if (instr) {
            if (params.showOriginalInstructionAsComment) {
                _text += "  ;  " + hex(currentInstruction);
            }
            _text += "\n";
        }
    }
    return _text;
}

bool Disassembler::onNOP() { return true; }

bool Disassembler::onCLS() {
    _text += "CLS";
    return true;
}
bool Disassembler::onRET() {
    _text += "RET";
    return true;
}
bool Disassembler::onCallMachine(uint16_t addr) {
    _text += "SYS " + hex(addr);
    return true;
}
bool Disassembler::onJump(uint16_t addr) {
    _text += "JP " + hex(addr);
    return true;
}
bool Disassembler::onCallSubroutine(uint16_t addr) {
    _text += "CALL " + hex(addr);
    return true;
}

bool Disassembler::onSkipIfVxIsVal(uint16_t reg, uint16_t val) {
    _text += "SE V" + hex(reg, false) + ", " + hex(val);
    return true;
}

bool Disassembler::onSkipIfVxIsNotVal(uint16_t reg, uint16_t val) {
    _text += "SNE V" + hex(reg, false) + ", " + hex(val);
    return true;
}

bool Disassembler::onSkipIfVxIsVy(uint16_t regX, uint16_t regY) {
    _text += "SE V" + hex(regX, false) + ", V" + hex(regY, false);
    return true;
}

bool Disassembler::onSetVx(uint16_t reg, uint16_t val) {
    _text += "LD V" + hex(reg, false) + ", " + hex(val);
    return true;
}

bool Disassembler::onAddValToVx(uint16_t reg, uint16_t val) {
    _text += "ADD V" + hex(reg, false) + ", " + hex(val);
    return true;
}

bool Disassembler::onSetVxToVy(uint16_t regX, uint16_t regY) {
    _text += "LD V" + hex(regX, false) + ", V" + hex(regY, false);
    return true;
}

bool Disassembler::onOrValToVx(uint16_t regX, uint16_t regY) {
    // 8xy1 - OR Vx, Vy
    _text += "OR V" + hex(regX, false) + ", V" + hex(regY, false);
    return true;
}

bool Disassembler::onAndValToVx(uint16_t regX, uint16_t regY) {
    // 8xy2 - AND Vx, Vy
    _text += "AND V" + hex(regX, false) + ", V" + hex(regY, false);
    return true;
}

bool Disassembler::onXOrValToVx(uint16_t regX, uint16_t regY) {
    // 8xy3 - XOR Vx, Vy
    _text += "XOR V" + hex(regX, false) + ", V" + hex(regY, false);
    return true;
}

bool Disassembler::onAddVyToVx(uint16_t regX, uint16_t regY) {
    _text += "ADD V" + hex(regX, false) + ", V" + hex(regY, false);
    return true;
}

bool Disassembler::onSubVyToVx(uint16_t regX, uint16_t regY) {
    _text += "SUB V" + hex(regX, false) + ", V" + hex(regY, false);
    return true;
}

bool Disassembler::onShiftRightVx(uint16_t reg) {
    _text += "SHR V" + hex(reg, false);
    return true;
}

bool Disassembler::onSubVxToVy(uint16_t regX, uint16_t regY) {
    _text += "SUBN V" + hex(regX, false) + ", V" + hex(regY, false);
    return true;
}

bool Disassembler::onShiftLeftVx(uint16_t reg) {
    _text += "SHL V" + hex(reg, false);
    return true;
}

bool Disassembler::onSkipNextIfVxIsNotVy(uint16_t regX, uint16_t regY) {
    _text += "SNE V" + hex(regX, false) + ", V" + hex(regY, false);
    return true;
}

bool Disassembler::onSetI(uint16_t addr) {
    _text += "LD I, " + hex(addr);
    return true;
}
bool Disassembler::onJumpToLoc(uint16_t addr) {
    _text += "JP V0, " + hex(addr);
    return true;
}
bool Disassembler::onRand(uint16_t reg, uint16_t val) {
    _text += "RND V" + hex(reg, false) + ", " + hex(val);
    return true;
}

bool Disassembler::onDisplay(uint16_t regX, uint16_t regY, uint8_t nimble) {
    assert(nimble != 0);
    _text += "DRW V" + hex(regX, false) + ", V" + hex(regY, false) + ", " +
             hex(nimble);
    return true;
}

bool Disassembler::onSuperChipDisplay(uint16_t regX, uint16_t regY) {
    _text += "DRW V" + hex(regX, false) + ", V" + hex(regY, false) + ", 0";
    return true;
}

bool Disassembler::onSkipIfKeyPressed(uint16_t reg) {
    _text += "SKP V" + hex(reg, false);
    return true;
}

bool Disassembler::onSkipIfKeyNotPressed(uint16_t reg) {
    _text += "SKNP V" + hex(reg, false);
    return true;
}

bool Disassembler::onSetVxToDelayTimer(uint16_t reg) {
    _text += "LD V" + hex(reg, false) + ", DT";
    return true;
}

bool Disassembler::onWaitKeyPressed(uint16_t reg) {
    _text += "LD V" + hex(reg, false) + ", K";
    return true;
}

bool Disassembler::onSetDelayTimer(uint16_t reg) {
    _text += "LD DT, V" + hex(reg, false);
    return true;
}

bool Disassembler::onSetSoundTimer(uint16_t reg) {
    _text += "LD ST, V" + hex(reg, false);
    return true;
}

bool Disassembler::onAddVxToI(uint16_t reg) {
    _text += "ADD I, V" + hex(reg, false);
    return true;
}

bool Disassembler::onSetIToSpriteLoc(uint16_t reg) {
    _text += "LD F, V" + hex(reg, false);
    return true;
}

bool Disassembler::onStoreBCDOfVxInI(uint16_t reg) {
    _text += "LD B, V" + hex(reg, false);
    return true;
}

bool Disassembler::onStoreVnInI(uint16_t reg) {
    _text += "LD I, V" + hex(reg, false);
    return true;
}

bool Disassembler::onReadVnFromI(uint16_t reg) {
    _text += "LD V" + hex(reg, false) + ", I";
    return true;
}

bool Disassembler::onExit() {
    _text += "EXIT";
    return true;
}

bool Disassembler::onSCR() {
    _text += "SCR";
    return true;
}

bool Disassembler::onSCL() {
    _text += "SCL";
    return true;
}

bool Disassembler::onScrollDown(uint8_t n) {
    _text += "SCD " + hex(n);
    return true;
}

bool Disassembler::onLowRes() {
    _text += "LOW";
    return true;
}

bool Disassembler::onHighRes() {
    _text += "HIGH";
    return true;
}

bool Disassembler::onSetIToBigSpriteLoc(uint16_t reg) {
    _text += "LD HF, V" + hex(reg, false);
    return true;
}

bool Disassembler::onSaveFlagRegister(uint8_t reg) {
    _text += "LD R, V" + hex(reg, false);
    return true;
}

bool Disassembler::onLoadFlagRegister(uint8_t reg) {
    _text += "LD V" + hex(reg, false) + ", R";
    return true;
}
