//
//  Disassembler.cpp
//  asm
//
//  Created by Manuel Deneu on 25/03/2025.
//

#include "Disassembler.hpp"

static void toUpper(std::string &str) {
    std::transform(str.begin(), str.end(), str.begin(), ::toupper);
}

static std::string hex(uint16_t value, bool prefix = true) {
    char str[16];
    char *p = &str[16];
    do {
        p--;
        uint32_t digit = value % 16;
        value /= 16;
        *p = digit >= 10 ? 'a' + (digit - 10) : '0' + digit;
    } while (value > 0);
    if (prefix) {
        p--;
        *p = 'X';
        p--;
        *p = '0';
    }
    auto ret = std::string(p, &str[16] - p);
    toUpper(ret);
    return ret;
}

bool Disassembler::loadFile(const std::string &path) {
    return Chip8::loadFile(path, _bytes);
}

std::string Disassembler::generate() {
    if (!params.noAutogeneratedComments) {
        _text = "; autogenerated from chip8 disassembler\n";
    }
    for (const auto &instr : _bytes) {
        if (!exec(instr)) {
            printf("Error at instruction 0X%04X\n", instr);
            return "";
        }
        _text += "\n";
    }
    return _text;
}

bool Disassembler::onCLS() {
    _text += "CLS";
    return true;
}
bool Disassembler::onRET() {
    _text += "RET";
    return true;
}
bool Disassembler::onCallMachine(uint16_t addr) {
    _text += "SYS " + hex(addr);
    return true;
}
bool Disassembler::onJump(uint16_t addr) {
    _text += "JP " + hex(addr);
    return true;
}
bool Disassembler::onCallSubroutine(uint16_t addr) {
    _text += "CALL " + hex(addr);
    return true;
}

bool Disassembler::onSkipIfVxIsVal(uint16_t reg, uint16_t val) {
    _text += "SE V" + hex(reg, false) + ", " + hex(val);
    return true;
}

bool Disassembler::onSkipIfVxIsNotVal(uint16_t reg, uint16_t val) {
    _text += "SNE V" + hex(reg, false) + ", " + hex(val);
    return true;
}
bool Disassembler::onSkipIfVxIsVy(uint16_t regX, uint16_t regY) {
    return false;
}
bool Disassembler::onSetVx(uint16_t reg, uint16_t val) {
    _text += "LD V" + hex(reg, false) + ", " + hex(val);
    return true;
}

bool Disassembler::onAddValToVx(uint16_t reg, uint16_t val) {
    _text += "ADD V" + hex(reg, false) + ", " + hex(val);
    return true;
}

bool Disassembler::onSetVxToVy(uint16_t regX, uint16_t regY) { return false; }
bool Disassembler::onOrValToVx(uint16_t reg, uint16_t val) { return false; }
bool Disassembler::onAndValToVx(uint16_t reg, uint16_t val) { return false; }
bool Disassembler::onXOrValToVx(uint16_t reg, uint16_t val) { return false; }
bool Disassembler::onAddVyToVx(uint16_t regX, uint16_t regY) { return false; }
bool Disassembler::onSubVyToVx(uint16_t regX, uint16_t regY) { return false; }
bool Disassembler::onShiftRightVx(uint16_t reg) { return false; }
bool Disassembler::onSubVxToVy(uint16_t regX, uint16_t regY) { return false; }
bool Disassembler::onShiftLeftVx(uint16_t reg) { return false; }

bool Disassembler::onSkipNextIfVxIsNotVy(uint16_t regX, uint16_t regY) {
    _text += "SNE V" + hex(regX, false) + ", V" + hex(regY, false);
    return true;
}

bool Disassembler::onSetI(uint16_t addr) {
    _text += "LD I, " + hex(addr);
    return true;
}
bool Disassembler::onJumpToLoc(uint16_t addr) {
    _text += "JP V0, " + hex(addr);
    return true;
}
bool Disassembler::onRand(uint16_t reg, uint16_t val) { return false; }
bool Disassembler::onDisplay(uint16_t regX, uint16_t regY, uint8_t nimble) {
    _text += "DRW V" + std::to_string(regX) + ", V" + std::to_string(regY) +
             ", " + hex(nimble);
    return true;
}
bool Disassembler::onSkipIfKeyPressed(uint16_t reg) { return false; }

bool Disassembler::onSkipIfKeyNotPressed(uint16_t reg) {
    _text += "SKNP V" + hex(reg, false);
    return true;
}

bool Disassembler::onSetVxToDelayTimer(uint16_t reg) {
    _text += "LD V" + hex(reg, false) + ", DT";
    return true;
}

bool Disassembler::onWaitKeyPressed(uint16_t reg) {
    _text += "LD V" + hex(reg, false) + ", K";
    return true;
}
bool Disassembler::onSetDelayTimer(uint16_t reg) {
    _text += "LD DT, V" + hex(reg, false);
    return true;
}
bool Disassembler::onSetSoundTimer(uint16_t reg) {
    _text += "LD ST, V" + hex(reg, false);
    return true;
}
bool Disassembler::onAddVxToI(uint16_t reg) { return false; }
bool Disassembler::onSetIToSpriteLoc(uint16_t reg) {
    _text += "LD F, V" + hex(reg, false);
    return true;
}
bool Disassembler::onStoreBCDOfVxInI(uint16_t reg) { return false; }
bool Disassembler::onStoreVnInI(uint16_t reg) { return false; }

bool Disassembler::onReadVnFromI(uint16_t reg) {
    _text += "LD V" + hex(reg, false) + ", I";
    return true;
}
